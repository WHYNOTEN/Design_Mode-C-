# **单例模式(Singleton Mode)**

​		单例模式（亦称单件模式），使用最广泛的设计模式。目的是为了保证一个类有且仅有一个实例，并提供一个访问它的全局访问点。

定义一个单例类步骤：

1. 私有化构造函数，防止外界创建单例类的对象
2. 使用类的私有静态指针变量指向类的唯一实例
3. 使用一个公有的静态方法获取该实例

单例模式主要分为两大类：

- 懒汉式（Lazy Singleton) : 实例在第一次被使用时才进行初始化，即延迟初始化。“时间换空间”

缺点：

1. 存在内存泄露
2. 单线程环境下，准确无误，但是多线程下，线程不安全

解决方案：

1.对于内存泄露，很好解决，使用智能指针，或者使用静态的嵌套对象

2.对于多线程的线程安全，利用同步机制，保护共享数据。即双锁检测机制(DLC),对share data进行加锁处理，

在C++11后，可以使用atomic关键字进行正确的跨平台的DLC实现

- 饿汉式（Eager Singleton）：实例在程序运行时，立即被执行初始化。“空间换时间”

------

总结：

​		1.饿汉式，线程安全，因为实在main()之前进行的初始化，但存在一些潜在问题（于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的）。详情见代码。

​		2.懒汉式通常需要加锁来保证线程安全，但局部静态变量版本在C++11后，线程是安全的。（C++11引进了memory model，提供了Atomic实现内存的同步访问，即不同线程总是获取对象修改前或修改后的值，无法在对象修改期间获得该对象。）

​		3.使用局部静态变量版本是最优解(>=C++11)



C++中，静态对象的初始化：

non-local static (即函数外)：

​	C++规定，non-local static 对象的初始化发生在main函数执行之前，也即main函数之前的单线程启动阶段，所以不存在线程安全问题。但C++没有规定多个non-local static 对象的初始化顺序，尤其是来自多个编译单元的non-local static对象，他们的初始化顺序是随机的，所以饿汉式的版本，存在一个潜在问题，线程获得的对象可能为空！

local static（函数内）

​	该类对象的初始化，发生在控制流第一次执行到该类对象的初始化语句时，多个线程可能同时到达其初始化语句。单线程时，不会发生问题，但是多线程，多个线程同时到达该语句时，有可能发生以下情况：A线程到达该语句，正在进行初始化，但尚未完成初始化，即该对象仍未null，那么B对象到达该语句，发现对象为null，B线程也会进行该对象初始化，就会导致该对象被多次初始化，造成内存泄露问题。所以，需要进行加锁来解决这个问题！

​	C++11后，该问题得到了解决，C++11规定：在一个线程开始local static对象的初始化后到完成初始化前，其他线程执行到该初始化语句就会被阻塞，直到该local static对象初始化完成！

参考文章：[c++ 单例模式](https://blog.csdn.net/song240948380/article/details/123074885)	（CSDN ）

​					[单例模式](https://www.runoob.com/design-pattern/singleton-pattern.html)	（菜鸟教程）

